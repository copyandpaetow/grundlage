# Idea

## parsing html

We have a html tagged template literal helper function that takes the static templateStringArray and turns it into documentFragment and descriptors for each slot.
Since the templateStringArray is unique, we can cache the result and avoid the parsing cost from string to documentFragment, which is usually one of the bottlenecks.

### fragment

the fragment marks the dynamic parts with comment nodes. Most descriptor types only need one comment node, the content descriptor needs 2 (to replace everything between on value change).
In the comment nodes we encode which binding index they have and which expression indices they need. Since one binding can be made out of multiple expressions these dont always match.

### descriptors

Descriptors describe the gaps/holes/slots of the tagged template literal input. There are currently 4 types: tag, attribute, rawContent (style, textArea), content
These descriptors have somewhat different shapes what mainly involve arrays with either string content or numbers

```ts
html`<div class="${dynamicClass1} static ${dynamicClass2}"></div>`[
	//becomes
	fragment: <!--marker--><div></div>
	descriptors: [{
		keys: ["class"],
		values: [0, "static ", 1],
	}],
	expressionToDescriptor: [0, 0]
];
```

They than can be combined with the expression array to the final html part (an attribute in this case). Like in the example above, a descriptor can be made out of more than one dynamic part.

## Bindings

### setup

In the begining we walk the fragment to find all relevant comment nodes and read out the encoded data: binding index and relvant expression indices.
We then take the binding at the encoded index, populate it into its own binding class, and store the same instance on the several expression index positions in a new array.

```ts

bindings: [attributeBinding1, attributeBinding1],
expressions: [dynamicClass1, dynamicClass2]

```

### updating

We compare the last array of expressions with the current one. If one expression changes, we can acccess the binding at the same index and call its update function

## usage

```ts

	render("component-name", function*(initialProps, element){

		yield html`<p> ...loading</p>`

		const data = await fetch(...)

		yield (props) => html`
			<ul>${data.map(entry => html`
				<li>${entry}</li>`
				)}
			</ul>`

		return () => console.log("cleanup")

	})

```
