# Grundlage

A small, zero-dependency library for building web components with tagged template literals.

## Installation

```bash
npm install grundlage
```

## Concepts

### Components as Generators

Components are defined using generator functions. This gives you explicit control over the component lifecycle: setup runs until you yield a render function, and the return value is your cleanup.

```javascript
import { render, html } from "grundlage";

render("async-component", async function* (props) {
	yield html`<p>loading</p>`;

	try {
		const data = await fetch(props.url);
		yield html`<p>name:${data.name} ${data.name}, age: ${data.age}</p>`;
	} catch (error) {
		yield html`<p>error: ${error}</p>`;
	}

	return () => {
		console.log("cleanup");
	};
});
```

### Templating

The `html` tagged template literal parses your markup once and caches the result. Subsequent renders only update the dynamic parts.

```javascript
html`<div class="card ${isActive ? "active" : ""}">
	<h2>${title}</h2>
	<p>${description}</p>
</div>`;
```

Supported bindings:

- Content: `<p>${text}</p>`
- Attributes: `<div class=${className}>`
- Mixed attributes: `<div class="static ${dynamic}">`
- Event handlers: `<button onClick=${handler}>`
- Lists: `<ul>${items.map(i => html`<li>${i}</li>`)}</ul>`
- Nested templates: `<div>${showDetails ? html`<details>...</details>` : null}</div>`
- Dynamic tags: `<${tagName}>content</${tagName}>`
- Raw content (style/script/textarea): `<style>${css}</style>`

### Reactivity

Grundlage uses a hash-based change detection system. When you call `ctx.update()`, it compares hashes of each expression to determine what actually changed.

This means:

- Primitives are compared by value
- Arrays and objects are compared by content (shallow)
- Nested templates are compared by structure and values
- DOM updates only happen for expressions that changed

```javascript
render("todo-list", function* (props, ctx) {
	const items = [];

	const add = (text) => {
		items.push({ id: Date.now(), text });
		ctx.update();
	};

	yield () => html`
		<ul>
			${items.map((item) => html`<li>${item.text}</li>`)}
		</ul>
	`;
});
```
